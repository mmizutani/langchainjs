---
id: vja4h
title: agents_with_vectorstores
file_version: 1.1.2
app_version: 1.5.2
---

# Agents with Vectorstores

This notebook covers how to combine agents and vectorstores. The use case for this is that you’ve ingested your data into a vectorstore and want to interact with it in an agentic manner.

The reccomended method for doing so is to create a VectorDBQAChain and then use that as a tool in the overall agent. Let’s take a look at doing this below. You can do this with multiple different vectordbs, and use the agent as a way to route between them. There are two different ways of doing this - you can either let the agent use the vectorstores as normal tools, or you can set return\_direct=True to really just use the agent as a router.

First, you want to import the relevant modules

```
import { OpenAI } from "langchain";
import { initializeAgentExecutor } from "langchain/agents";
import { SerpAPI, Calculator, ChainTool } from "langchain/tools";
import { VectorDBQAChain } from "langchain/chains";
import { HNSWLib } from "langchain/vectorstores";
import { OpenAIEmbeddings } from "langchain/embeddings";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import * as fs from "fs";
```

Next, you want to create the vectorstore with your data, and then the QA chain to interact with that vectorstore.

```
const model = new OpenAI({ temperature: 0 });
/* Load in the file we want to do question answering over */
const text = fs.readFileSync("state_of_the_union.txt", "utf8");
/* Split the text into chunks */
const textSplitter = new RecursiveCharacterTextSplitter({ chunkSize: 1000 });
const docs = await textSplitter.createDocuments([text]);
/* Create the vectorstore */
const vectorStore = await HNSWLib.fromDocuments(docs, new OpenAIEmbeddings());
/* Create the chain */
const chain = VectorDBQAChain.fromLLM(model, vectorStore);
```

Now that you have that chain, you can create a tool to use that chain. Note that you should update the name and description to be specific to your QA chain.

```
const qaTool = new ChainTool({
  name: "state-of-union-qa",
  description:
    "State of the Union QA - useful for when you need to ask questions about the most recent state of the union address.",
  chain: chain,
});
```

Now we can go about constructing and using the tool as we would any other tool!

```
const tools = [new SerpAPI(), new Calculator(), qaTool];

const executor = await initializeAgentExecutor(
  tools,
  model,
  "zero-shot-react-description"
);
console.log("Loaded agent.");

const input = `What did biden say about ketanji brown jackson is the state of the union address?`;

console.log(`Executing with input "${input}"...`);

const result = await executor.call({ input });

console.log(`Got output ${result.output}`);
```

You can also set return\_direct=True if you intend to use the agent as a router and just want to directly return the result of the VectorDBQaChain.

```
const qaTool = new ChainTool({
  name: "state-of-union-qa",
  description:
    "State of the Union QA - useful for when you need to ask questions about the most recent state of the union address.",
  chain: chain,
  returnDirect: true,
});
```

<br/>

This file was generated by Swimm. [Click here to view it in the app](/repos/Z2l0aHViJTNBJTNBbGFuZ2NoYWluanMlM0ElM0FtbWl6dXRhbmk=/docs/vja4h).
